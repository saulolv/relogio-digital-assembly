
AVRASM ver. 2.2.8  C:\Users\ander\Documents\Estudos\projeto micro\relogio-digital-assembly\digital-clock\main.asm Sat Apr 12 01:29:12 2025

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
C:\Users\ander\Documents\Estudos\projeto micro\relogio-digital-assembly\digital-clock\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
C:\Users\ander\Documents\Estudos\projeto micro\relogio-digital-assembly\digital-clock\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
                                 
                                 .include "m328pdef.inc" ; Inclui definições do ATmega328P
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #define _M328PDEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega328P
                                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x0f
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; 
                                 .equ	FOC1A	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register
                                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ    SELFPRGEN = 0; Added for backwards compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                                 .equ    SIGRD   = 5 ; Signature Row Read
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; 
                                 .equ	IVSEL	= 1	; 
                                 .equ	PUD	= 4	; 
                                 .equ	BODSE	= 5	; BOD Sleep Enable
                                 .equ	BODS	= 6	; BOD Sleep
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	EXTREF	= EXTRF	; For compatibility
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select reset vector
                                 .equ	BOOTSZ0	= 1	; Select boot size
                                 .equ	BOOTSZ1	= 2	; Select boot size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x08ff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                                 
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 #define CLOCK 16000000 ;clock speed
                                 #define DELAY 1
                                 #define BAUD 9600       ; Define a taxa de baud da serial
                                 #define UBRR_VALUE (((CLOCK / (BAUD * 16.0)) + 0.5) - 1) ; Calcula UBRR
                                 ;#define DELAY_ms 10
                                 ;.equ DELAY_CYCLES = int(CLOCK * DELAY_ms) / 1000
                                 
                                 .def actual_mode = r18  ; Armazena o modo atual de operação (relógio, cronômetro, ajuste...)
                                 .def temp1 = r16        ; Variavel temporaria
                                 .def temp2 = r17        ; Variavel temporaria
                                 .def tx_byte = r19      ; Byte a ser transmitido pela serial
                                 .def byte_val = r20     ; Byte a ser convertido para ASCII decimal
                                 .def ascii_H = r21      ; Digito ASCII das dezenas
                                 .def ascii_L = r22      ; Digito ASCII das unidades
                                 ; Usaremos Z (r31:r30) como ponteiro para strings na memória de programa
                                 
                                 
                                 .dseg
000100                           mode_1: .byte 2
000102                           mode_2: .byte 3
000105                           adjust_digit_selector: .byte 1 ; Variável para MODO 3 (0=Sec Uni, 1=Sec Dez, 2=Min Uni, 3=Min Dez)
000106                           trocar_modo_flag: .byte 1
                                 
                                 
                                 .cseg
                                 ; --- Vetores de Interrupção ---
                                 .cseg
                                 .org 0x0000
000000 940c 008b                     jmp reset
                                 
                                 .org PCI0addr
000006 940c 010e                     jmp pcint0_isr
                                 
                                 .org OC1Aaddr
000016 940c 0118                     jmp OCI1A_ISR
                                 
                                 ; --- Strings para a Serial ---
000018 4d5b
000019 444f
00001a 204f
00001b 5d31
00001c 0020                      str_modo1: .db "[MODO 1] ", 0
00001d 4d5b
00001e 444f
00001f 204f
000020 5d32
000021 5220
000022 4e55
000023 0020                      str_modo2_run: .db "[MODO 2] RUN ", 0
000024 4d5b
000025 444f
000026 204f
000027 5d32
000028 5320
000029 4f54
00002a 5050
00002b 4445
00002c 0020                      str_modo2_stop: .db "[MODO 2] STOPPED ", 0
00002d 4d5b
00002e 444f
00002f 204f
000030 5d32
000031 5a20
000032 5245
000033 004f                      str_modo2_zero: .db "[MODO 2] ZERO", 0
000034 4d5b
000035 444f
000036 204f
000037 5d33
000038 4120
000039 756a
00003a 7473
00003b 6e61
00003c 6f64
00003d 6120
00003e 7520
00003f 696e
000040 6164
000041 6564
000042 6420
000043 736f
000044 7320
000045 6765
000046 6e75
000047 6f64
000048 0073                      str_modo3_su: .db "[MODO 3] Ajustando a unidade dos segundos", 0
000049 4d5b
00004a 444f
00004b 204f
00004c 5d33
00004d 4120
00004e 756a
00004f 7473
000050 6e61
000051 6f64
000052 6120
000053 6420
000054 7a65
000055 6e65
000056 2061
000057 6f64
000058 2073
000059 6573
00005a 7567
00005b 646e
00005c 736f
00005d 0020                      str_modo3_sd: .db "[MODO 3] Ajustando a dezena dos segundos ", 0
00005e 4d5b
00005f 444f
000060 204f
000061 5d33
000062 4120
000063 756a
000064 7473
000065 6e61
000066 6f64
000067 6120
000068 7520
000069 696e
00006a 6164
00006b 6564
00006c 6420
00006d 736f
00006e 6d20
00006f 6e69
000070 7475
000071 736f
000072 0020                      str_modo3_mu: .db "[MODO 3] Ajustando a unidade dos minutos ", 0
000073 4d5b
000074 444f
000075 204f
000076 5d33
000077 4120
000078 756a
000079 7473
00007a 6e61
00007b 6f64
00007c 6120
00007d 6420
00007e 7a65
00007f 6e65
000080 2061
000081 6f64
000082 2073
000083 696d
000084 756e
000085 6f74
000086 0073                      str_modo3_md: .db "[MODO 3] Ajustando a dezena dos minutos", 0
000087 003a                      str_colon: .db ":", 0
000088 725c
000089 6e5c
00008a 0020                      str_newline: .db "\r\n ", 0 ; Envia Carriage Return e Line Feed para compatibilidade
                                 
                                 reset:
                                     ; --- Inicialização da Pilha ---
00008b ef0f                          ldi r16, low(RAMEND)
00008c bf0d                          out SPL, r16
00008d e008                          ldi r16, high(RAMEND)
00008e bf0e                          out SPH, r16
                                 
                                 	; PB4 como saída
00008f e100                          ldi r16, (1 << PB4)
000090 b904                          out DDRB, r16
                                 
                                     ; Ativa pull-up interno em PB5
000091 e200                          ldi r16, (1 << PB5)
000092 b905                          out PORTB, r16
                                 
                                     ; Habilita interrupção de mudança de pino PCINT0 (PORTB)
000093 e001                          ldi r16, (1 << PCIE0)
000094 9300 0068                     sts PCICR, r16
                                 
                                     ; Habilita interrupção para PB5 (PCINT5)
000096 e200                          ldi r16, (1 << PCINT5)
000097 9300 006b                     sts PCMSK0, r16
                                 
                                 
000099 b10b                          in temp1, PORTD
00009a 6c00                          ori temp1, (1 << PD6) | (1 << PD7)
00009b b90b                          out PORTD, temp1
                                 
                                     ; Ativa pull-up em PD6 (RESET) e PD7 (START)
00009c b10a                          in temp1, DDRD
00009d 730f                          andi temp1, 0b00111111     ; PD6 e PD7 como entrada
00009e b90a                          out DDRD, temp1
                                 
00009f e10f                      	ldi temp1, 0b00011111     ; PB0–PB4 como saída
0000a0 b904                      	out DDRB, temp1
                                 
                                 	
                                     ; --- Inicialização das Variáveis ---
0000a1 e000                          ldi temp1, 0              ; Carrega o valor 0 no registrador temp1 (r16)
0000a2 9300 0100                 	sts mode_1, temp1         ; Zera os minutos atuais do relógio (mode_1 = 0)
0000a4 9300 0101                 	sts mode_1 + 1, temp1     ; Zera os segundos atuais do relógio (mode_1 + 1 = 0)
0000a6 9300 0102                 	sts mode_2, temp1         ; Zera os minutos do cronômetro (mode_2 = 0)
0000a8 9300 0103                 	sts mode_2 + 1, temp1     ; Zera os segundos do cronômetro (mode_2 + 1 = 0)
0000aa 9300 0104                 	sts mode_2 + 2, temp1     ; Zera a flag de ativação do cronômetro (mode_2 + 2 = 0)
0000ac 9300 0105                     sts adjust_digit_selector, temp1 ; Zera seletor de ajuste
                                 
                                 
                                     ; --- Configuração do Timer1 (Mantido do original) ---
0000ae e002                          ldi temp1, (1 << OCIE1A)  ; Carrega no registrador temp1 um valor com o bit OCIE1A ativado (bit que habilita a interrupção do Timer1 Compare Match A)
0000af 9300 006f                 	sts TIMSK1, temp1         ; Escreve esse valor no registrador TIMSK1, ativando a interrupção do Timer1 (Canal A)
                                     .equ PRESCALE = 0b100           ; Seleciona o prescaler do Timer1 como 256 (CS12:CS10 = 100)
                                 	.equ PRESCALE_DIV = 256         ; Valor real do prescaler (divisor de clock)
                                 	.equ WGM = 0b0100               ; Define o modo de operação do Timer1 como CTC (Clear Timer on Compare Match)
                                 	.equ TOP = int(0.5 + ((CLOCK/PRESCALE_DIV)*DELAY))
                                 
0000b1 ef04                      	ldi temp1, high(TOP)              ; Carrega o byte mais significativo do valor TOP no registrador temp1
0000b2 9300 0089                 	sts OCR1AH, temp1                 ; Armazena esse valor no registrador OCR1AH (parte alta do valor de comparação do Timer1)
0000b4 e204                      	ldi temp1, low(TOP)               ; Carrega o byte menos significativo do valor TOP no registrador temp1
0000b5 9300 0088                 	sts OCR1AL, temp1                 ; Armazena esse valor no registrador OCR1AL (parte baixa do valor de comparação do Timer1)
0000b7 e000                      	ldi temp1, ((WGM & 0b11) << WGM10) ; Extrai os 2 bits menos significativos de WGM e posiciona em WGM10/WGM11
0000b8 9300 0080                 	sts TCCR1A, temp1                 ; Configura os bits de modo de operação do Timer1 no registrador TCCR1A
0000ba e00c                      	ldi temp1, ((WGM >> 2) << WGM12) | (PRESCALE << CS10)
0000bb 9300 0081                 	sts TCCR1B, temp1                 ; Configura modo CTC e ativa o prescaler de 256 no registrador TCCR1B
                                 	
                                     ; --- Configuração do USART ---
0000bd e000                          ldi temp1, high(int(UBRR_VALUE))
0000be 9300 00c5                     sts UBRR0H, temp1
0000c0 e607                          ldi temp1, low(int(UBRR_VALUE))
0000c1 9300 00c4                     sts UBRR0L, temp1
                                     ; Habilita transmissor (TXEN0)
0000c3 e008                          ldi temp1, (1 << TXEN0)
0000c4 9300 00c1                     sts UCSR0B, temp1
                                     ; Configura formato do frame: 8 bits de dados (UCSZ00, UCSZ01), 1 stop bit (padrão)
0000c6 e006                          ldi temp1, (1 << UCSZ01) | (1 << UCSZ00)
0000c7 9300 00c2                     sts UCSR0C, temp1
                                 
                                     ; --- Estado Inicial e Interrupções ---
0000c9 e021                          ldi actual_mode, 1                ; Define o modo inicial como 1 (Relógio)
0000ca 9478                          sei                               ; Habilita interrupções globais
                                 
                                 main:
                                     ; Verifica flag de troca de modo
0000cb 9100 0106                     lds temp1, trocar_modo_flag
0000cd 3001                          cpi temp1, 1
0000ce f411                          brne verificar_botoes
                                 
                                     ; Beep e troca de modo
0000cf d006                          rcall beep_modo
0000d0 d009                          rcall trocar_modo
                                 
                                 
                                 ; ============================
                                 ; CONTROLE DE MODO E BOTÕES
                                 ; ============================
                                 verificar_botoes:
                                     ; Se estiver no MODO 2, verifica START e RESET
0000d1 3022                          cpi actual_mode, 2
0000d2 f409                          brne continuar
0000d3 d010                          rcall verifica_botoes_modo2
                                 
                                 continuar:
                                     ; Multiplexação do display
0000d4 d0e1                          rcall multiplexar_display
0000d5 cff5                          rjmp main
                                 
                                 
                                 ; --- Função: Emitir beep curto (PB4) ---
                                 beep_modo:
0000d6 9a2c                          sbi PORTB, PB4
0000d7 d12c                          rcall delay_multiplex
0000d8 982c                          cbi PORTB, PB4
0000d9 9508                          ret
                                 
                                 
                                 ; --- Função: Trocar modo atual (1 → 2 → 3 → 1) ---
                                 trocar_modo:
0000da 2f02                          mov temp1, actual_mode
0000db 9503                          inc temp1
0000dc 3004                          cpi temp1, 4
0000dd f008                          brlo modo_ok
0000de e001                          ldi temp1, 1
                                 modo_ok:
0000df 2f20                          mov actual_mode, temp1
0000e0 e000                          ldi temp1, 0
0000e1 9300 0106                     sts trocar_modo_flag, temp1
0000e3 9508                          ret
                                 
                                 
                                 
                                 ; --- Função: Verificar botões START (PD7) e RESET (PD6) ---
                                 verifica_botoes_modo2:
                                     ; Verifica botão START (PD7)
0000e4 994f                          sbic PIND, PD7
0000e5 c003                          rjmp verifica_reset
0000e6 d008                          rcall aciona_start
                                 esperar_soltar_start:
0000e7 9b4f                          sbis PIND, PD7
0000e8 cffe                          rjmp esperar_soltar_start
                                 
                                 verifica_reset:
                                     ; Verifica botão RESET (PD6)
0000e9 994e                          sbic PIND, PD6
0000ea c003                          rjmp fim_verifica_botoes
0000eb d011                          rcall aciona_reset
                                 esperar_soltar_reset:
0000ec 9b4e                          sbis PIND, PD6
0000ed cffe                          rjmp esperar_soltar_reset
                                 
                                 fim_verifica_botoes:
0000ee 9508                          ret
                                 
                                 
                                 ; --- Função: Inverter flag do cronômetro e avisar "[MODO 2] START" ---
                                 aciona_start:
0000ef 9100 0104                     lds temp1, mode_2+2
0000f1 e011                          ldi temp2, 1
0000f2 2701                          eor temp1, temp2
0000f3 9300 0104                     sts mode_2+2, temp1
                                 
0000f5 dfe0                          rcall beep_modo
                                 
0000f6 e3ea                          ldi ZL, low(str_modo2_run<<1)
0000f7 e0f0                          ldi ZH, high(str_modo2_run<<1)
0000f8 d11d                          rcall USART_Transmit_String
0000f9 e1e0                          ldi ZL, low(str_newline<<1)
0000fa e0f1                          ldi ZH, high(str_newline<<1)
0000fb d11a                          rcall USART_Transmit_String
                                 
0000fc 9508                          ret
                                 
                                 
                                 ; --- Função: Resetar cronômetro (se parado) e avisar "[MODO 2] RESET" ---
                                 aciona_reset:
0000fd 9100 0104                     lds temp1, mode_2+2
0000ff 3000                          cpi temp1, 0
000100 f461                          brne reset_nop
                                 
000101 e000                          ldi temp1, 0
000102 9300 0102                     sts mode_2, temp1
000104 9300 0103                     sts mode_2+1, temp1
                                 
000106 dfcf                          rcall beep_modo
                                 
000107 e4e8                          ldi ZL, low(str_modo2_stop<<1)
000108 e0f0                          ldi ZH, high(str_modo2_stop<<1)
000109 d10c                          rcall USART_Transmit_String
00010a e1e0                          ldi ZL, low(str_newline<<1)
00010b e0f1                          ldi ZH, high(str_newline<<1)
00010c d109                          rcall USART_Transmit_String
                                 
                                 reset_nop:
00010d 9508                          ret
                                 
                                 
                                 ; --- INTERRUPÇÃO PCINT0 ---
                                 pcint0_isr:
00010e 930f                          push temp1
                                 
                                     ; Detecta botão pressionado
00010f b103                          in temp1, PINB
000110 ff05                          sbrs temp1, PB5
000111 c001                          rjmp seta_flag_troca_modo
                                 
000112 c003                          rjmp fim_interrupcao_pcint0
                                 
                                 seta_flag_troca_modo:
000113 e001                          ldi temp1, 1
000114 9300 0106                     sts trocar_modo_flag, temp1  ; Marca a flag
                                 fim_interrupcao_pcint0:
000116 910f                          pop temp1
000117 9518                          reti
                                 
                                 
                                 
                                 
                                 ; =========================================================================
                                 ; ROTINA DE INTERRUPÇÃO DO TIMER 1 - EXECUTADA A CADA SEGUNDO
                                 ; =========================================================================
                                 OCI1A_ISR:
                                     ; --- Salvar Contexto ---
000118 930f                          push temp1          ; r16
000119 931f                          push temp2          ; r17
00011a 933f                          push r19            ; tx_byte (usado por USART_Transmit)
00011b 934f                          push r20            ; byte_val (usado por Send_Decimal_Byte)
00011c 935f                          push r21            ; ascii_H  (usado por Send_Decimal_Byte)
00011d 936f                          push r22            ; ascii_L  (usado por Send_Decimal_Byte)
00011e 93ef                          push r30            ; ZL (usado por USART_Transmit_String)
00011f 93ff                          push r31            ; ZH (usado por USART_Transmit_String)
000120 b70f                          in temp1, SREG      ; Salva SREG
000121 930f                          push temp1
                                 
                                     ; --- Lógica de Atualização (Relógio/Cronômetro) ---
000122 3021                          cpi actual_mode, 1
000123 f029                          breq update_and_send_mode1 ; Se Modo 1, atualiza relógio e envia serial
000124 3022                          cpi actual_mode, 2
000125 f089                          breq update_and_send_mode2 ; Se Modo 2, atualiza cronômetro e envia serial
000126 3023                          cpi actual_mode, 3
000127 f1c1                          breq send_mode3            ; Se Modo 3, só envia serial (tempo não avança)
000128 c054                          rjmp isr_end               ; Modo inválido? Sai.
                                 
                                 update_and_send_mode1:
000129 d05e                          rcall hora_atual         ; Atualiza o relógio
                                     ; Enviar Serial Modo 1: "[MODO 1] MM:SS"
00012a e3e0                          ldi ZL, low(str_modo1<<1)
00012b e0f0                          ldi ZH, high(str_modo1<<1)
00012c d0e9                          rcall USART_Transmit_String
00012d 9140 0100                     lds byte_val, mode_1      ; Carrega minutos
00012f d0f2                          rcall Send_Decimal_Byte   ; Envia MM
000130 e0ee                          ldi ZL, low(str_colon<<1)
000131 e0f1                          ldi ZH, high(str_colon<<1)
000132 d0e3                          rcall USART_Transmit_String ; Envia ":"
000133 9140 0101                     lds byte_val, mode_1+1    ; Carrega segundos
000135 d0ec                          rcall Send_Decimal_Byte   ; Envia SS
000136 c043                          rjmp send_newline_and_exit
                                 
                                 update_and_send_mode2:
000137 d065                          rcall cronometro         ; Atualiza o cronômetro (se ativo)
                                     ; Enviar Serial Modo 2
000138 9100 0104                     lds temp1, mode_2+2      ; Carrega flag de ativação
00013a 3000                          cpi temp1, 0
00013b f069                          breq check_mode2_zero    ; Se flag=0 (parado), verifica se está zerado
                                     ; Se chegou aqui, cronômetro está rodando
00013c e3ea                          ldi ZL, low(str_modo2_run<<1)
00013d e0f0                          ldi ZH, high(str_modo2_run<<1)
00013e d0d7                          rcall USART_Transmit_String
00013f 9140 0102                     lds byte_val, mode_2      ; Carrega minutos do cronômetro
000141 d0e0                          rcall Send_Decimal_Byte
000142 e0ee                          ldi ZL, low(str_colon<<1)
000143 e0f1                          ldi ZH, high(str_colon<<1)
000144 d0d1                          rcall USART_Transmit_String ; Envia ":"
000145 9140 0103                     lds byte_val, mode_2+1    ; Carrega segundos do cronômetro
000147 d0da                          rcall Send_Decimal_Byte
000148 c031                          rjmp send_newline_and_exit
                                 
                                 check_mode2_zero:
000149 9100 0102                     lds temp1, mode_2         ; Minutos
00014b 9110 0103                     lds temp2, mode_2+1       ; Segundos
00014d 2b01                          or temp1, temp2           ; Se ambos forem 0, resultado é 0
00014e f421                          brne mode2_stopped        ; Se não for zero, está parado mas não zerado
                                     ; Se chegou aqui, cronômetro está parado e zerado
00014f e5ea                          ldi ZL, low(str_modo2_zero<<1)
000150 e0f0                          ldi ZH, high(str_modo2_zero<<1)
000151 d0c4                          rcall USART_Transmit_String
000152 c027                          rjmp send_newline_and_exit
                                 
                                 mode2_stopped:
                                     ; Cronômetro parado mas não zerado
000153 e4e8                          ldi ZL, low(str_modo2_stop<<1)
000154 e0f0                          ldi ZH, high(str_modo2_stop<<1)
000155 d0c0                          rcall USART_Transmit_String
000156 9140 0102                     lds byte_val, mode_2      ; Carrega minutos do cronômetro
000158 d0c9                          rcall Send_Decimal_Byte
000159 e0ee                          ldi ZL, low(str_colon<<1)
00015a e0f1                          ldi ZH, high(str_colon<<1)
00015b d0ba                          rcall USART_Transmit_String ; Envia ":"
00015c 9140 0103                     lds byte_val, mode_2+1    ; Carrega segundos do cronômetro
00015e d0c3                          rcall Send_Decimal_Byte
00015f c01a                          rjmp send_newline_and_exit
                                 
                                 send_mode3:
                                     ; Enviar Serial Modo 3: Mensagem depende do dígito selecionado
000160 9100 0105                     lds temp1, adjust_digit_selector ; Carrega qual dígito está sendo ajustado
000162 3000                          cpi temp1, 0
000163 f039                          breq send_m3_su
000164 3001                          cpi temp1, 1
000165 f049                          breq send_m3_sd
000166 3002                          cpi temp1, 2
000167 f059                          breq send_m3_mu
000168 3003                          cpi temp1, 3
000169 f069                          breq send_m3_md
00016a c00f                          rjmp send_newline_and_exit ; Se valor inválido, apenas envia newline
                                 
                                 send_m3_su:
00016b e6e8                          ldi ZL, low(str_modo3_su<<1)
00016c e0f0                          ldi ZH, high(str_modo3_su<<1)
00016d d0a8                          rcall USART_Transmit_String
00016e c00b                          rjmp send_newline_and_exit
                                 send_m3_sd:
00016f e9e2                          ldi ZL, low(str_modo3_sd<<1)
000170 e0f0                          ldi ZH, high(str_modo3_sd<<1)
000171 d0a4                          rcall USART_Transmit_String
000172 c007                          rjmp send_newline_and_exit
                                 send_m3_mu:
000173 ebec                          ldi ZL, low(str_modo3_mu<<1)
000174 e0f0                          ldi ZH, high(str_modo3_mu<<1)
000175 d0a0                          rcall USART_Transmit_String
000176 c003                          rjmp send_newline_and_exit
                                 send_m3_md:
000177 eee6                          ldi ZL, low(str_modo3_md<<1)
000178 e0f0                          ldi ZH, high(str_modo3_md<<1)
000179 d09c                          rcall USART_Transmit_String
                                     ;rjmp send_newline_and_exit ; Já vai para o próximo passo
                                 
                                 send_newline_and_exit:
                                     ; Envia Newline para finalizar a mensagem
00017a e1e0                          ldi ZL, low(str_newline<<1)
00017b e0f1                          ldi ZH, high(str_newline<<1)
00017c d099                          rcall USART_Transmit_String
                                 
                                 isr_end:
                                     ; --- Restaurar Contexto ---
00017d 910f                          pop temp1
00017e bf0f                          out SREG, temp1     ; Restaura SREG
00017f 91ff                          pop r31             ; ZH
000180 91ef                          pop r30             ; ZL
000181 916f                          pop r22             ; ascii_L
000182 915f                          pop r21             ; ascii_H
000183 914f                          pop r20             ; byte_val
000184 913f                          pop r19             ; tx_byte
000185 911f                          pop temp2           ; r17
000186 910f                          pop temp1           ; r16
000187 9518                          reti                ; Retorna da interrupção
                                 
                                 ; =========================================================================
                                 ; FUNÇÕES DE ATUALIZAÇÃO
                                 ; =========================================================================
                                 hora_atual:
000188 930f                          push temp1               ; Salva registradores temporários
000189 931f                          push temp2
00018a 9110 0101                     lds temp2, mode_1 + 1    ; Carrega segundos atuais do relógio
00018c 9513                          inc temp2                ; Incrementa 1 segundo
00018d 331c                          cpi temp2, 60            ; Verifica se chegou a 60 segundos
00018e f449                          brne save_seconds        ; Se não, só salva os segundos
                                 atualiza_minuto_atual:
00018f 9100 0100                     lds temp1, mode_1        ; Carrega minutos atuais
000191 9503                          inc temp1                ; Incrementa minutos
000192 330c                          cpi temp1, 60            ; Verifica se chegou a 60 minutos (opcional, depende se quer que vire 00:00)
000193 f409                          brne save_minutes
000194 e000                          ldi temp1, 0             ; Zera minutos se chegou a 60
                                 save_minutes:
000195 9300 0100                     sts mode_1, temp1        ; Salva minutos atualizados
000197 e010                          ldi temp2, 0             ; Zera os segundos
                                 save_seconds:
000198 9310 0101                     sts mode_1 + 1, temp2    ; Salva segundos atualizados
00019a 911f                          pop temp2                ; Restaura registradores
00019b 910f                          pop temp1
00019c 9508                          ret                      ; Retorna da função
                                 
                                 cronometro:
00019d 930f                          push temp1               ; Salva registradores temporários
00019e 931f                          push temp2
00019f 9100 0104                     lds temp1, mode_2 + 2    ; Lê a flag de ativação do cronômetro
0001a1 3000                          cpi temp1, 0
0001a2 f081                          breq crono_end           ; Se for 0, cronômetro está desligado -> sai
                                     ; Se chegou aqui, cronômetro está ativo
0001a3 9110 0103                     lds temp2, mode_2 + 1    ; Lê os segundos do cronômetro
0001a5 9513                          inc temp2                ; Incrementa 1 segundo
0001a6 331c                          cpi temp2, 60
0001a7 f449                          brne crono_save_seconds  ; Se não chegou a 60, só salva os segundos
                                 atualiza_minuto_cronometro:
0001a8 9100 0102                     lds temp1, mode_2        ; Lê os minutos
0001aa 9503                          inc temp1                ; Incrementa minutos
0001ab 330c                          cpi temp1, 60            ; Verifica se chegou a 60 minutos (opcional)
0001ac f409                          brne crono_save_minutes
0001ad e000                          ldi temp1, 0             ; Zera minutos se chegou a 60
                                 crono_save_minutes:
0001ae 9300 0102                     sts mode_2, temp1        ; Salva minutos atualizados
0001b0 e010                          ldi temp2, 0             ; Zera os segundos
                                 crono_save_seconds:
0001b1 9310 0103                     sts mode_2 + 1, temp2    ; Salva os segundos atualizados
                                 crono_end:
0001b3 911f                          pop temp2                ; Restaura registradores
0001b4 910f                          pop temp1
0001b5 9508                          ret                      ; Retorna da função
                                 
                                 
                                 ; =========================================================================
                                 ; FUNÇÕES DE DISPLAY
                                 ; =========================================================================
                                 multiplexar_display:
                                     ; Seleciona os dados corretos conforme o modo
0001b6 3022                          cpi actual_mode, 2
0001b7 f079                          breq usa_dados_cronometro
                                 
                                 usa_dados_relogio:
0001b8 9100 0101                     lds temp1, mode_1 + 1    ; Segundos
0001ba e01a                          ldi temp2, 10
0001bb 940e 01f9                     call dividir             ; temp1 = dezena, temp2 = unidade
0001bd 2f71                          mov r23, temp2           ; Sec Unid
0001be 2f80                          mov r24, temp1           ; Sec Dez
                                 
0001bf 9100 0100                     lds temp1, mode_1        ; Minutos
0001c1 e01a                          ldi temp2, 10
0001c2 940e 01f9                     call dividir
0001c4 2f91                          mov r25, temp2           ; Min Unid
0001c5 2fa0                          mov r26, temp1           ; Min Dez
0001c6 c00e                          rjmp exibir_valores
                                 
                                 usa_dados_cronometro:
0001c7 9100 0103                     lds temp1, mode_2 + 1
0001c9 e01a                          ldi temp2, 10
0001ca 940e 01f9                     call dividir
0001cc 2f71                          mov r23, temp2
0001cd 2f80                          mov r24, temp1
                                 
0001ce 9100 0102                     lds temp1, mode_2
0001d0 e01a                          ldi temp2, 10
0001d1 940e 01f9                     call dividir
0001d3 2f91                          mov r25, temp2
0001d4 2fa0                          mov r26, temp1
                                 
                                 exibir_valores:
0001d5 2f07                          mov temp1, r23
0001d6 d01b                          rcall enviar_para_cd4511
0001d7 b115                          in temp2, PORTB
0001d8 7f10                          andi temp2, 0b11110000
0001d9 6018                          ori temp2, (1 << PB3)
0001da b915                          out PORTB, temp2
0001db d028                          rcall delay_multiplex
                                 
0001dc 2f08                          mov temp1, r24
0001dd d014                          rcall enviar_para_cd4511
0001de b115                          in temp2, PORTB
0001df 7f10                          andi temp2, 0b11110000
0001e0 6014                          ori temp2, (1 << PB2)
0001e1 b915                          out PORTB, temp2
0001e2 d021                          rcall delay_multiplex
                                 
0001e3 2f09                          mov temp1, r25
0001e4 d00d                          rcall enviar_para_cd4511
0001e5 b115                          in temp2, PORTB
0001e6 7f10                          andi temp2, 0b11110000
0001e7 6012                          ori temp2, (1 << PB1)
0001e8 b915                          out PORTB, temp2
0001e9 d01a                          rcall delay_multiplex
                                 
0001ea 2f0a                          mov temp1, r26
0001eb d006                          rcall enviar_para_cd4511
0001ec b115                          in temp2, PORTB
0001ed 7f10                          andi temp2, 0b11110000
0001ee 6011                          ori temp2, (1 << PB0)
0001ef b915                          out PORTB, temp2
0001f0 d013                          rcall delay_multiplex
                                 
0001f1 9508                          ret
                                 
                                 
                                 enviar_para_cd4511:
0001f2 0f00                          lsl temp1
0001f3 0f00                          lsl temp1
0001f4 b11b                          in temp2, PORTD
0001f5 7c13                          andi temp2, 0b11000011
0001f6 2b10                          or temp2, temp1
0001f7 b91b                          out PORTD, temp2
0001f8 9508                          ret
                                 
                                 dividir:
0001f9 933f                          push r19
0001fa 2733                          clr r19
                                 div_loop:
0001fb 1701                          cp temp1, temp2
0001fc f018                          brlo fim_div
0001fd 1b01                          sub temp1, temp2
0001fe 9533                          inc r19
0001ff cffb                          rjmp div_loop
                                 fim_div:
000200 2f10                          mov temp2, temp1
000201 2f03                          mov temp1, r19
000202 913f                          pop r19
000203 9508                          ret
                                 
                                 delay_multiplex:
000204 938f                          push r24
000205 939f                          push r25
000206 e193                          ldi r25, high(5000) ;SUJEITO A MUDANÇA
000207 e888                          ldi r24, low(5000)
                                 delay_loop:
000208 9701                          sbiw r24, 1
000209 f7f1                          brne delay_loop
00020a 919f                          pop r25
00020b 918f                          pop r24
00020c 9508                          ret
                                 
                                 
                                 ; =========================================================================
                                 ; FUNÇÕES DA SERIAL
                                 ; =========================================================================
                                 
                                 ; --- USART_Transmit ---
                                 ; Envia um byte pela serial. Espera o buffer estar livre.
                                 ; Entrada: tx_byte (r19) contém o byte a ser enviado
                                 USART_Transmit:
00020d 930f                          push temp1          ; Salva r16
                                 tx_wait_loop:
00020e 9100 00c0                     lds temp1, UCSR0A   ; Lê o status do USART
000210 ff05                          sbrs temp1, UDRE0   ; Pula a próxima instrução se o bit UDRE0 (Data Register Empty) estiver setado (1)
000211 cffc                          rjmp tx_wait_loop   ; Se não estiver vazio (UDRE0=0), espera
000212 9330 00c6                     sts UDR0, tx_byte   ; Coloca o byte no buffer de transmissão (envia)
000214 910f                          pop temp1           ; Restaura r16
000215 9508                          ret
                                 
                                 ; --- USART_Transmit_String ---
                                 ; Envia uma string (terminada em NULL) localizada na memória de programa (Flash).
                                 ; Entrada: Z (r31:r30) aponta para o início da string na memória de programa.
                                 ; Usa: Z, tx_byte (r19), temp1 (r16)
                                 USART_Transmit_String:
000216 930f                          push temp1          ; Salva r16
000217 93ef                          push r30
000218 93ff                          push r31
                                 str_loop:
000219 9135                          lpm tx_byte, Z+     ; Carrega byte da memória de programa no tx_byte e incrementa Z
00021a 2333                          tst tx_byte         ; Verifica se o byte carregado é zero (NULL terminator)
00021b f011                          breq str_end        ; Se for zero, fim da string
00021c dff0                          rcall USART_Transmit ; Envia o byte
00021d cffb                          rjmp str_loop       ; Próximo caractere
                                 str_end:
00021e 91ff                          pop r31
00021f 91ef                          pop r30
000220 910f                          pop temp1           ; Restaura r16
000221 9508                          ret
                                 
                                 ; --- Send_Decimal_Byte ---
                                 ; Converte um byte (0-99) em dois caracteres ASCII decimais e os envia pela serial.
                                 ; Entrada: byte_val (r20) contém o valor (0-99)
                                 ; Saída: Envia os dois caracteres ASCII pela serial
                                 ; Usa: byte_val (r20), ascii_H (r21), ascii_L (r22), tx_byte (r19), temp1 (r16)
                                 Send_Decimal_Byte:
000222 930f                          push temp1           ; Salva r16
000223 931f                          push r17           ; Salva r17
000224 934f                          push r20           ; Salva byte_val original se precisar depois
                                 
000225 2f04                          mov temp1, byte_val  ; Copia valor para temp1 (usado por div10)
000226 d00c                          rcall div10          ; Chama sub-rotina de divisão por 10
                                                          ; Resultado: temp1=quociente (dezena), temp2=resto (unidade)
                                 
000227 2f50                          mov ascii_H, temp1   ; Guarda a dezena
000228 2f61                          mov ascii_L, temp2   ; Guarda a unidade
                                 
                                     ; Converte dezena para ASCII ('0' = 0x30)
000229 5d50                          subi ascii_H, -0x30  ; Adiciona 0x30
00022a 2f35                          mov tx_byte, ascii_H ; Prepara para transmitir
00022b dfe1                          rcall USART_Transmit ; Envia dígito das dezenas
                                 
                                     ; Converte unidade para ASCII
00022c 5d60                          subi ascii_L, -0x30  ; Adiciona 0x30
00022d 2f36                          mov tx_byte, ascii_L ; Prepara para transmitir
00022e dfde                          rcall USART_Transmit ; Envia dígito das unidades
                                 
00022f 914f                          pop r20
000230 911f                          pop r17
000231 910f                          pop temp1
000232 9508                          ret
                                 
                                 
                                 ; --- div10 ---
                                 ; Sub-rotina simples para dividir por 10 (útil para BCD/ASCII)
                                 ; Entrada: temp1 = valor (0-99)
                                 ; Saída: temp1 = quociente (Dezena), temp2 = resto (Unidade)
                                 ; Usa: temp1, temp2
                                 div10:
000233 2711                          clr temp2           ; temp2 será o quociente (dezenas)
                                 div10_loop:
000234 300a                          cpi temp1, 10       ; Compara com 10
000235 f018                          brlo div10_end      ; Se for menor, acabou
000236 500a                          subi temp1, 10      ; Subtrai 10
000237 9513                          inc temp2           ; Incrementa quociente
000238 cffb                          rjmp div10_loop
                                 div10_end:
                                     ; No fim: temp1 tem o resto (unidade), temp2 tem o quociente (dezena)
                                     ; Troca para retornar como especificado (temp1=quociente, temp2=resto)
000239 930f                          push temp1
00023a 2f01                          mov temp1, temp2
00023b 911f                          pop temp2
00023c 9508                          ret
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
x  :   0 y  :   0 z  :   1 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 132 r17:  58 r18:   8 r19:  12 r20:  11 
r21:   5 r22:   5 r23:   3 r24:   7 r25:   6 r26:   3 r27:   0 r28:   0 
r29:   0 r30:  20 r31:  20 
Registers used: 14 out of 35 (40.0%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   0 adiw  :   0 and   :   0 
andi  :   6 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  11 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :   9 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   4 cbi   :   1 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   2 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   1 cpc   :   0 
cpi   :  19 cpse  :   0 dec   :   0 eor   :   1 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   9 inc   :   7 jmp   :   3 
ld    :   0 ldd   :   0 ldi   :  65 lds   :  23 lpm   :   1 lsl   :   2 
lsr   :   0 mov   :  22 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   2 ori   :   5 out   :  13 pop   :  25 
push  :  25 rcall :  45 ret   :  15 reti  :   2 rjmp  :  21 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   1 sbic  :   2 sbis  :   2 
sbiw  :   1 sbr   :   0 sbrc  :   0 sbrs  :   2 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 sts   :  27 
sub   :   1 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 37 out of 113 (32.7%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00047a    880    230   1110   32768   3.4%
[.dseg] 0x000100 0x000107      0      7      7    2048   0.3%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
